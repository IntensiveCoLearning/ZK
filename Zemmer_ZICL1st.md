---
timezone: Asia/Shanghai

---


1. 我是Zemmer，后端转合约，专注defi和nft。
2. 能完成本次残酷学习。
3. 目前阶段对ZK了解了一些，没有系统学习，正好遇到，拿下。

## Notes

<!-- Content_START -->

### 2024.07.29
## zk的概念

1、允许作为证明者的一方在不透露其他信息的情况下让作为验证者的另一方相信某个事实或声明。

2、ZKP的目的是：证明我有这个事实。

3、ZKP并不是“零”知识，而是不透露除了这个事实之外的其他任何信息。

## 关于Knowledge和information的区别举例

我觉得在合约的角度，知识聚焦于交易相关概念的判断，而信息不仅包含知识，而且聚焦于单个变量的数值。

| 知识                                     | 信息                           |
| ---------------------------------------- | ------------------------------ |
| 1、某个地址拥有大于100的ETH              | 1、地址0x99拥有121.3ETH        |
| 2、某个交易的交易方属于某个DAO           | 2、区块的生成时间是12828382938 |
| 3、某个mint后但未reveal的NFT属于某个地址 |                                |
| 4、交易0x88的交易双方都是EOA             |                                |

## NP问题

### P和NP的概念

1、P问题：可以在多项式时间（而不是指数时间）内求解的问题

2、NP问题：可以在多项式时间内验证解的正确性的问题。

### NP问题特点

1、难以求解，但易于验证。

2、P问题是NP问题的子集：即P问题易于求解，也易于验证。

### NP完全问题NP Complete

1、如果能在多项式时间内解决任何一个NP完全问题,就能解决所有NP问题

2、所有NP问题都可以归约到某个NP完全问题

### 常见NP问题

1、图着色问题Graph Coloring：给定一个图和k种颜色，是否可以用这k种颜色给图的顶点着色，使得相邻顶点颜色不同？

2、汉密尔顿回路问题Hamiltonian Cycle：在给定的图中，是否存在一条经过每个顶点恰好一次的回路

3、子集和问题Subset Sum：给定一组数字和一个目标值，这组数字是否存在一个子集，其和等于目标值？

4、布尔可满足性问题Boolean Satisfiability Problem, SAT：给定一个布尔表达式，是否存在一组变量赋值使表达式为真？

5、整数分解问题Integer Factorization：给定一个大整数，找出它的质因数。

### 关于三色图

#### 1、三色图的游戏规则

1、需要地图上n块地图，一共三种颜色国家，相邻的两块颜色都不同。

2、地图遮住颜色。

3、验证者每次只能要求揭露相邻的两块地图颜色。

4、如果验证的结果是颜色不同，则验证通过，说明证明者正确。

5、验证者可以多次验证。

#### 2、三色图的刷新机制

三色图规则有一个非常巧妙的地方，就是每次验证者验证之后，整体的答案进行了刷新，证明者仍保证当前答案符合游戏规则。

#### 3、分析

1、刷新规则代表了证明者可以证明给验证者一个事实：我这次是对的，也就是这个局部是对的。

2、但不能证明一个事实：我这次的其他地方也是对的，也就是整体是对的。

3、对于验证者来说，他清楚每次有1/2的概率证明者可能出错。

4、然而，如果证明者确实有三色图的答案，那么就不可能出现验证错误的情况。

5、这就像抛硬币，虽然每次有1/2的可能性抛出头像那一面，但是如果你每次都抛出头像面，那么我可以认为你这个硬币只有一面。

6、感觉这是一种无限逼近的证明，不是完备的证明。


### 2024.07.30

## ZK的两种技术：ZK-snarks和ZK-starks的区别

| 特性         | zk-SNARKs                                         | zk-STARKs                                          |
| ------------ | ------------------------------------------------- | -------------------------------------------------- |
| **扩展性**   | 需要可信设置，扩展性较差                          | 不需要可信设置，扩展性更强                         |
| **安全性**   | 依赖复杂数学假设（如椭圆曲线和Pairing-based加密） | 基于哈希函数，依赖较少的假设，更加简单和可靠       |
| **证明尺寸** | 证明尺寸较小，验证时间较短，适合在区块链上使用    | 证明尺寸较大，生成和验证的资源消耗较大             |
| **应用率**   | 已有较成熟的开发生态，应用较广泛                  | 技术更先进，但应用较少，开发生态还不够成熟         |
| **可信验证** | 需要可信设置来生成公共参数                        | 不需要可信设置，证明是完全透明的，任何人都可以验证 |

## layer2的zk技术

optimistic：假设所有交易都有效，如果出问题再检测。

zk-rollup：需要每个交易都附带证明

### 数据存储方式三种

rollup：

validadium：数据存在链下，有点像预制菜，菜单是有效性证明！预制菜本身代表线下储存。

volition：数据存储方式：结合了zk-rollup和validadium结合。

### rollup的项目

lookpring

zksync

starknet

# 今天学习结果很差，非常松散，需要系统的针对某一些基础进行深挖。

### 2024.07.31
今天只学了一个zk游戏，和三色图的有点类似，具体如下
## 抛硬币猜测色彩游戏

### 要求

verifier在不看页面的前提下，通过交互式来判断页面只有一个颜色还是两个颜色。

### 前提条件

1、页面上有一个矩形图形，矩形对称轴将其分成两部分。

2、每个部分可能有两个颜色，分别是绿色和紫色。也有可能都是一个颜色，比如全绿色或全紫色。

3、硬币有两面head和tail。

4、verifier是色盲，无法分辨页面颜色，但可以分辨硬币是哪一面。

5、prover不是色盲，可以分辨页面颜色。

6、prover知道verifier会投掷硬币，且会根据投掷硬币结果去决定是否翻转页面。

7、prover和verifier都诚实。

### 交互验证流程

1、prover将页面给verifier。

2、verifier抛硬币，并自己设定规则来根据硬币是哪一面来决定是否给页面翻面。假设当前游戏规则是抛出heads，则翻转页面。

3、verifier将操作完的页面给prover，prover收到该页面。

#### 当前交互总结

| 掌握的知识                       | prover                     | verifier |
| -------------------------------- | -------------------------- | -------- |
| 页面是一个颜色还是两个           | 是                         | 否       |
| verifier投掷硬币的是head还是tail | 否                         | 是       |
| verifier是否翻转了页面           | 如果页面两色则是，单色则否 | 是       |

1、截止当前步骤，verifier掌握的信息只有他投掷的硬币是哪一面。

2、prover知道verifier抛了硬币，但不确定verifier是哪一面，因为prover和verifier并没有在游戏之前商量好是抛哪一面才翻转。

3、prover掌握的信息是页面的初始原色，以及页面是否被翻转这两个信息。而如果页面初始是两个颜色，他是可以100%掌握页面是否被翻转这个信息的。但如果页面初始是一个颜色，他无法掌握页面是否被翻转这个信息。

### 继续交互流程

4、prover需要猜测verifier设定的翻转规则，有两种：第一种是抛head翻转，而tail不翻转。第二种是抛tail翻转而head不翻转。

5、prover根据猜测的结果和页面的情况来回复verifier说：“你的coin抛了head”或“你的coin抛了tail"

6、verifier得到这个消息，和自己实际抛售的结果进行比较。

#### 当前交互总结

| 掌握的知识                                         | prover                     | verifier |
| -------------------------------------------------- | -------------------------- | -------- |
| 页面是一个颜色还是两个                             | 是                         | 否       |
| verifier投掷硬币的是head还是tail                   | 否                         | 是       |
| verifier是否翻转了页面                             | 如果页面两色则是，单色则否 | 是       |
| prover猜测的硬币面是否和verifier实际抛的硬币面一样 | 否                         | 是       |

### 此轮验证结束，循环开始下一轮验证。

### 举例

#### 前提1：

| 页面颜色 | verifier的规则 | prover的规则 |
| -------- | -------------- | ------------ |
| 2        | head -> 翻     | 翻 -> head   |

| 次数 | verifier 抛出真实 | prover看到结果 | Prove的回答 | Prover回答和verifier的是否一致 |
| ---- | ----------------- | -------------- | ----------- | ------------------------------ |
| 1    | head              | 翻了           | head        | 是                             |
| 2    | tail              | 没翻           | tail        | 是                             |

所以结果：这种情况下，永远一致。因此：正确率100%，页面颜色是2。

#### 前提2：

| 页面颜色 | verifier的规则 | prover的规则 |
| -------- | -------------- | ------------ |
| 2        | head -> 翻     | 不翻 -> head |

| 次数 | verifier 抛出真实 | prover看到结果 | Prove的回答 | Prover回答和verifier的是否一致 |
| ---- | ----------------- | -------------- | ----------- | ------------------------------ |
| 1    | head              | 翻了           | tail        | 否                             |
| 2    | tail              | 没翻           | head        | 否                             |

所以结果：这种情况下，永远不一致。因此：正确率0%，页面颜色是2。

#### 前提3：

| 页面颜色 | verifier的规则 | prover的规则 |
| -------- | -------------- | ------------ |
| 2        | head -> 不翻   | 翻 -> head   |

| 次数 | verifier 抛出真实 | prover看到结果 | Prove的回答 | Prover回答和verifier的是否一致 |
| ---- | ----------------- | -------------- | ----------- | ------------------------------ |
| 1    | head              | 没翻           | tail        | 否                             |
| 2    | tail              | 翻了           | head        | 否                             |

所以结果：这种情况下，永远不一致。因此：正确率0%，页面颜色是2。

#### 前提4：

| 页面颜色 | verifier的规则 | prover的规则 |
| -------- | -------------- | ------------ |
| 2        | head -> 不翻   | 不翻 -> head |

| 次数 | verifier 抛出真实 | prover看到结果 | Prove的回答 | Prover回答和verifier的是否一致 |
| ---- | ----------------- | -------------- | ----------- | ------------------------------ |
| 1    | head              | 没翻           | head        | 是                             |
| 2    | tail              | 翻了           | tail        | 是                             |

所以结果：这种情况下，永远一致。因此：正确率100%，页面颜色是2。

#### 前提5678：

在这种情况下，由于prover看到的结果是没变化的，因此prover不能确定是否verifier是否进行了翻转，进而prover自己设置什么规则，都不可能无因有果，最后prover的回复是随机回复，无法确定的。

| 页面颜色 | verifier的规则 | prover的规则 |
| -------- | -------------- | ------------ |
| 1        | head -> 翻     | 翻 -> head   |
| 1        | head -> 翻     | 不翻 -> head |
| 1        | head -> 不翻   | 翻 -> head   |
| 1        | head -> 不翻   | 不翻 -> head |

| 次数 | verifier 抛出真实 | prover看到结果 | Prove的回答 | Prover回答和verifier的是否一致 |
| ---- | ----------------- | -------------- | ----------- | ------------------------------ |
| 1    | head              | 没变化         | 随机回答    | 不确定                         |
| 2    | tail              | 没变化         | 随机回答    | 不确定                         |

所以结果：这种情况下，回答有时候正确有时候错误。因此：正确率可能会在50%附近浮动（未必，要根据prover的性格来确定），页面颜色是1。

### 结论

1、如果prover的回答100%正确或者100%错误，则verifier判断此页面为2色。

2、如果prover的回答不是100%正确或者100%错误，则verifier判断此页面为1色。

## 游戏结论
1、zk需要将一个复杂问题从数学上转化为概率问题。
2、而且这个概率问题需要通过多轮独立的挑战验证来实现统计。


### 2024.08.01
学不动了，直接先磕circom，从后往前捯饬吧。
# Circom

## 相关定义

### signals：

1、信号，感觉就是参数

2、每个参数是一个多项式的未知数（元）

3、不仅仅是输入的参数，包括整个电路过程中所有的变量在不同时候值都算是signal。

### R1CS

1、Rank-1 constraint system，称之为：秩 1 约束系统。

2、一个电路代码的限制系统

3、要求所有的参数都符合二次、线性等式。而且可以通过公式消元。

4、所有多项式的计算都是在有限域上的运算，也就是模运算。

### witness

1、一组可以满足电路的信号

2、也就是R1CS的解决方案之一

3、简单的说就是一组有效的输入参数args。

### 输入input和输出out put

1、都属于signals

2、输入分为私有输入private和公开输入public input

3、私有输入就是不能透露的信息，也就是零知识的那部分。比如私钥。

### 可信设置trusted setup

1、

## 安装步骤

### 安装rust

```
cd ~
curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh
```

### 安装circom

```
git clone https://github.com/iden3/circom.git
```

```
cd circom
cargo build --release
cargo install --path circom
```

circus binary将安装在$HOME/.cargo/bin下。

### 测试

```
circom --help
```

### 安装snark.js

```
npm install -g snarkjs
```

## 使用circom的整体步骤

### 1、撰写circom

得到一个.circom文件，该文件内部建立了template的实例。

### 2、编译circom

编译命令：circom 文件名

```
circom multiplier2.circom --r1cs --wasm --sym --c
```

#### 参数解释

##### --r1cs

1、生成 fileName.r1cs文件

2、该文件是电路中R1CS的二进制

##### --wasm

1、生成了fileName_js文件夹

2、该文件夹内包含fileName.wasm文件，以及其它文件

3、这些文件的内容是在JavaScript环境下生成见证人witness

##### --sym

1、生成了fileName.sym文件

2、用于调试和以注释模式打印约束系统。

##### --c

1、生成了fileName_cpp文件夹

2、该文件夹包含了fileName.cpp和fileName.dat等文件

3、这些文件也是用来在C++环境下生成见证人witness的。性能更好（但每个证明的生成时间里见证人只是其中一部分）

##### -o

1、用于指定输出文件的目录。

2、默认是当前目录

##### -l

添加库搜索路径，即指定额外的目录，circom会在这些目录中查找include指令引用的电路文件。

### 3、计算见证人witness

1、设计一组和wasm文件对应的实参，并将参数放入自定义的json文件中，比如命名为input.json。

```json
{"a": "3", "b": "11"}
```

2、将这个文件放入fileName_js文件夹中，即和fileName.wasm同一目录下。

3、在该文件目录下，运行以下文件生成证明文件.wtns。此命令使用 Node.js 运行 generate_witness.js，参数依次是输入的fileName.wasm文件、电路输入的 JSON 文件input.json，和生成的自定义的witness文件witness.wtns。

```bash
node generate_witness.js multiplier2.wasm input.json witness.wtns
```

### 4、证明电路

#### 生成电路所需的文件

1、wtns文件：见证人文件，包含所有的信号。

2、r1cs文件：约束文件，包含电路约束

3、未完待续

### 2024.08.02

## Circom语法

### 结束语法

和js一样，每一行代码结束后使用分号;

### 数据类型

普通数据：x

列表数据：x[N]

### 信号signal

#### 信号类型

1、输入信号，类型是input

2、输出信号，类型是output

3、中间信号，没有指明类型的全部是中间信号。

#### 信号声明

格式：signal 变量类型 变量名，如果没有变量类型则为中间变量。

```circom
signal input in;
signal output out[N];
signal inter;
```

#### 公开信号和私有信号

##### 性质

1、私有信号只有自己（证明人）可知，也就是只有电路内访问，外部不可访问。

2、公开信号证明人和验证人都可见，也就是电路外可访问。

3、所有的信号默认都是私有信号。

4、主组件中所有的输出信号都是公开信号.

##### 标识公开信号的方式

1、只有在主组件中可以定义公开信号。

2、定义的语法是使用public语法如下。

3、注意如果不定义公开信号的话仍为私有信号。

```
component main {public [in1,in2]} = Multiplier2();
```

#### 信号的不可更改型immutable

所有的信号都不能二次赋值，即只能赋值一次。


### 2024.08.03
#### 信号的值

1、信号的值只能是数字、布尔值或者数字列表

2、circom没有字符串这个概念。

#### 约束constrain

1、定义信号signal之间的关系。

2、这些关系在电路执行时候（以及证明过程中）必须满足。

3、一个模板之中通常有多个约束。

##### 信号约束相关符号

| 符号 | 解释                                    | 常用度     |
| ---- | --------------------------------------- | ---------- |
| <==  | 约束+赋值，常用语信号signal中，用于约束 | 常用       |
| ==>  | 和<==一样，就是方向不同                 | 很少       |
| ===  | 仅仅约束，不赋值                        | 常用       |
| <--  | 仅赋值，不约束                          | 很少       |
| -->  | 和<--一样，就是方向不同                 | 很少       |
| =    | 变量赋值var、component等。              | 不用于信号 |

##### 约束示例

1、有两个约束，第一个是out <== -in * inv + 1;，第二个是in * out === 0;

2、虽然第二个约束看起来没用，但还是能增加系统鲁棒性。

```js
/* 判断数字是否是0：输入一个数，当这个数字为0时候输出1，当这个数字不0时候输出0.*/
pragma circom 2.0.0;

template IsZero() {
    signal input in;
    signal output out;
    signal inv;
    inv <-- in != 0 ? 1/in : 0;
    out <== -in * inv + 1;
    in * out === 0;
}

component main {public [in]} = IsZero();

```

### 变量var

和信号的不同，尤其是中间信号

| 异同点   | var                                | signal |
| -------- | ---------------------------------- | ------ |
| 赋值号   | =                                  | <==    |
| 使用场景 | 临时变量赋值，循环变量，不能做约束 | 约束   |
| 赋值次数 | 多次                               | 1次    |
|          |                                    |        |



### 模版template和组件component

1、template定义了电路逻辑

#### template的参数

1、template可以有参数。

2、template的参数在component中赋值实参，因为component是实例化的意思。

3、不能把template的参数赋值给信号。因为信号是生成见证人阶段从外部输入的。

4、也不能把信号赋值给template参数，因为template实参是以常量形式在代码中输入的，而且是在编译阶段执行实例化的。

```js
template tempid ( param_1, ... , param_n ) {
 signal input a;
 signal output b;

 .....

}

component c = tempid(v1,...,vn);
```

#### component

1、是实例化的模版

2、模版如果有参数，必须在这个阶段输入参数

3、可以通过.来获取实例中的信号。

#### 主组件main component



### 有限域

circom的有限域的模p值为：

```
p = 21888242871839275222246405745257275088548364400416034343698204186575808495617.
```

### 判断

#### if else判断

```js
  if(N > 0){
     a = A(N);
  }
  else{
     a = A(0);
  }
```

#### 三元表达式

布尔条件? true值: false值;



```
var z = x>y? x : y;
```
### 2024.08.04

### 函数

1、函数内无法声明信号，或者创建约束，这只能是模版template的功能。

```js
function funid ( param1, ... , paramn ) {

 .....

 return x;
}
```

2、如果函数有返回值，且返回值是根据判断条件来决定的，那么需要做到每个判断条件都定义返回值，不能存在开放的条件没有返回值的情况。（即有if必须有else或者包含else的其他情况）。

```js
// 错误，当 N < 0 时，没有返回值
function example(N){
    if (N >= 0) {
        return 1;
    } 
}


// 正确
function example(N){
    if (N >= 0) {
        return 1;
    }
    else{
        return 0;
    }
}

// 正确
function example(N){
    if (N >= 0) {
        return 1;
    }
    return 0;
}
```

### 导入电路

1、不同于import，circom用语法include来导入其它电路文件

2、文件名必须加后缀.circom

3、可以使用-l参数，具体什么意思不知道。

```
include "montgomery.circom";
include "mux3.circom";
include "babyjub.circom";
```

### 运算符

#### 布尔运算符

和：&&

或：||

非：!

#### 算数运算符

1、所有的算数运算符都是模运算，包含加减乘除幂。

2、/是乘以逆元，例如10/3 mod11的意思是10 * 8 mod 11 也就是3 mod 11。

3、\是整除，且不进行模运算，返回a/b的整数部分。

4、%取余，切不进行模运算，返回a/b的余数。

### 2024.08.05
### 断言assertion

1、语法：assert(布尔表达式);

2、注意不仅在编译阶段进行检查，而且会在运行阶段进行检查。比如编译可能正确，但是运行可能错误。这是因为断言的条件可能包含了输入信号：

```js
// 这个电路可以编译成功，但如果在运行阶段（生成见证阶段）输入信号in > 254，则会报错
template Translate(n) {
  signal input in;  
  assert(in <= 254);
  . . .
}

```

### 调试打印log

语法：log(变量/常量/表达式/字符串)，可以用,连接

### 编译阶段调试命令

####  --sym详解

1、该命令生成了fileName.sym文件

2、该命令后面可以跟一个参数，该参数表示信号简化的程度，该参数值为默认没有， -O0 或 --O1

3、该文件表示了该电路内每个信号的详细信息，虽然不是实际传输的见证。（这里电路类似于形参，而见证类似于实参）

4、内有四个字段，分别为\#s, #w, #c, name

| 内容 | 定义     | 解释                                                         | 示例         |
| ---- | -------- | ------------------------------------------------------------ | ------------ |
| #s   | 信号编号 | 每个信号都有一个整数编号，从1开始，顺序排列                  | 1            |
| #w   | 见证位置 | 信号在见证中的位置。<br />如果不是public signal且不出现在最终的R1CS约束中，则值为-1 | 2            |
| #c   | 组件编号 | 标注信号来自于哪个组件<br />从0开始的非负整数                | 0            |
| name | 信号名称 | 信号全称，格式为：组件名.信号名                              | main.c.in[1] |

##### 一组.sym文件示例

```txt
1,1,1,main.out
2,2,1,main.in[0]
3,3,1,main.in[1]
4,-1,0,main.c.out
5,-1,0,main.c.in[0]
6,-1,0,main.c.in[1]

```

### 
#### 匿名组件

1、算是一种组件的语法糖，只支持circom2.1+

2、语法是：temp_name(arg1,...,argN)(input1,...,inputM)，要注意input信号的顺序。

##### 匿名组件示例

1、示例：传统组件

```js
// 创建一个电路A，输入信号两个，输出信号一个，约束是输出信号=输入信号相乘。
template A(n){
   signal input a, b;
   signal output c;
   c <== a*b;
}
//  创建一个电路B，输入信号是一个数组，输出信号一个，约束借助于A，也就是等于输出信号=输入信号数组内第一个元素和第二个元素相乘
template B(n){
   signal input in[n];
   signal out;
   component temp_a = A(n);
   temp_a.a <== in[0]; 
   temp_a.b <== in[1];
   out <== temp_a.c;
}
component main = B(2);
```

2、匿名改造

```js
template A(n){
   signal input a, b;
   signal output c;
   c <== a*b;
}
template B(n){
   signal input in[n];
   signal out <== A(n)(in[0],in[1]);
}
component main = B(2);
```

##### 总结匿名组件的语法

1、普通组件需要通过component来定义，而匿名组件不需要，直接实例化模板，比如直接A(n)

2、普通组件通过 实例.输入信号 进行电路之间的信号传递，而匿名组件通过实例(输入信号)的语法来进行信号传递，比如A(n)(x,y) 

3、普通组件的输出需要通过 实例.输出信号来传递，而匿名组件直接对结果进行约束，比如signal out <== A(n)(in[0],in[1]);

##### 匿名组件的输出信号

1、没有输出信号：直接temp_name(arg1,...,argN)(input1,...,inputM);

2、有一个输出信号：signal out1 <== temp_name(arg1,...,argN)(input1,...,inputM);

3、多个输出信号：使用元组

```js
signal output a1, a2, a3;
(a1, a2, a3) <== temp_name(arg1,...,argN)(input1,...,inputM);
```

4、可以通过语法_来忽略其中部分输出信号（把对应的约束也忽略了）

```js
template A(n){
   signal input a;
   signal output b, c, d;
   b <== a * a;
   c <== a + 2;
   d <== a * a + 2;
}
template B(n){
   signal input in;
   signal output out1;
   (_,out1,_) <== A(n)(in);  // 只留下c
}
component main = B(3);
```

5、扩展：元组也适合变量var

```js
var  a1, a2, a3;
(a1, a2, a3) = temp_name(arg1,...,argN)(input1,...,inputM);
```



#### 

#circom基础语法学习结束，明天开始回到zk#

### 2024.08.06

### Circom典型电路
注意这两个电路都不作为零知识证明，只是作为基础电路被引用到其它zkp电路中。

#### Num2Bit

功能：将十进制数字转化为二进制

```js
pragma circom 2.0.0;

template Num2Bits(n) {
    signal input in;
    signal output out[n];
    var lc1=0;
    var e2=1;
    for (var i = 0; i<n; i++) {
        out[i] <-- (in >> i) & 1;
        out[i] * (out[i] -1 ) === 0;
        lc1 += out[i] * e2;
        e2 = e2+e2;
    }
    lc1 === in;
}

component main {public [in]}= Num2Bits(3);
```



#### isZero

功能：判断输入的是0还是1。

```js
pragma circom 2.0.0;

template IsZero() {
    signal input in;
    signal output out;
    signal inv;
    inv <-- in!=0 ? 1/in : 0;
    out <== -in*inv +1;
    in*out === 0;
}

component main {public [in]}= IsZero();
```

### 2024.08.07
没学
### 2024.08.08
# 零知识证明系统的数学表达
以下的表都不保证对，要命

## 前提

1、R：一个可以高效计算的二元运算关系，即变量x和y之间的运算关系。这种关系可以是四则运算、hash运算、椭圆曲线有限域上运算等。

2、(x, w)：一个二元组，符合R运算，其中w是私有输入例如私钥，x是公开输入例如公钥。

## 步骤

存在五个算法阶段

| 算法阶段   | 生成     | 解释                                                        |
| ---------- | -------- | ----------------------------------------------------------- |
| sysGen     | 系统参数 | 生成椭圆曲线初始的系统参数：比如椭圆曲线的公式、有限域p等。 |
| commitment | 承诺     | prover选择随机数r，发送承诺C = Com(x, w; r)                 |
| challenge  | 挑战     | verifier从特定域中选择随机数e，发送给prover                 |
| response   | 响应     | 证明根据挑战生成响应：z = Response(x, w; e, r)              |
| Verify     | 验证     | verifier基于Com、验证响应 v = Verify(x, C, e, z)            |

# 
## zk-snarks的七个等价转化关系

等价转化的意思：将复杂问题简单化，最终转化为可以高效验证的形式。

| 关系                                                         | 原理简述或公式                     | 举例 |
| ------------------------------------------------------------ | ---------------------------------- | ---- |
| 计算关系                                                     | y=F(ω)，初始出入ω                  |      |
| R1CS（电路约束）                                             | 将算法用电路表达出来               |      |
| 向量s与多维向量/电路向量(u~m~, v~m~, w~m~)的内积             | 多变量多项式的零点对应R1CS约束的解 |      |
| 向量s与电路矩阵U,V,W的内积                                   |                                    |      |
| 向量s与三组多项式U(x),V(x),W(x)的线性组合运算（系数）        |                                    |      |
| 目标多项式整除QAP或QSP多项式                                 | 构成NP问题                         |      |
| QAP多项式、目标多项式、商多项式的多指数运算                  | 构成零知识证明                     |      |
| 基于这三个多项式UVW的系数计算椭圆曲线离散对数点（双线性映射） | 验证                               |      |

## 非交互式零知识证明和数字签名的区别

Alice：Prover/Signer。Bob：Verifier

| 阶段             | 人    | NIZKP           | ECDSA signature                        | signature           | Schnorr signature |
| ---------------- | ----- | --------------- | -------------------------------------- | ------------------- | ----------------- |
| 由私钥sk生成公钥 | Alice | Pk = sk.G       | Pk = sk.G                              | Pk = sk.G           | Pk = sk.G         |
| 生成随机数r      | Alice | r               | r                                      | r                   | r                 |
| 生成承诺R        | Alice | R = r.G         | R= r.G，其中R^x^是R的横坐标            | R = r.G             | R = r.G           |
| 加密消息         | Alice | 无              | m = Hash(M) mod n                      | m = Hash(M)         | m = Hash(M)       |
| 生成挑战c        | Alice | c = Hash(Pk, R) | c = Hash(R, m)                         | c = Hash(Pk, R, m)  | c = Hash(R, m)    |
| 计算             | Alice | z = r + c.sk    | s = r^-1^(m+R^x^.sk) mod n             | z = r + c.sk        | z = r + c.sk      |
| 组合并传递给Bob  | Alice | (R, z)          | (R^x^, s)                              | (R, z)              | (R, z)            |
| 计算             | Bob   | c' =Hash(Pk, R) |                                        | c' = Hash(Pk, R, m) | R' = z.G - c.Pk   |
| 验证             | Bob   | z.G =R +c'.Pk   | R' = (s^-1^.m).G + (s^-1^.R^x^).Pk = R | z.G = R + c'.Pk     | R' = R            |

r的作用：随机数，就是为了保密私钥sk的。作用等价于sk。

Tornado cash的原理是，通过zk证明知道Merkle Tree中的保密随机数r，就等于知道了私钥sk，就可以提资产了（也就是不必直接知道sk）


<!-- Content_END -->
